
from django.shortcuts import render, get_object_or_404, redirect
from django.http import HttpResponse, Http404
from django.contrib import messages
import json, os, subprocess, re
from subprocess import Popen, PIPE
from datetime import datetime, timedelta
import time
from django.http import JsonResponse, HttpResponse, HttpResponseRedirect
from django.conf import settings
from django.template.loader import get_template, render_to_string
from django.contrib.auth.decorators import login_required, user_passes_test
from todo.utils import staff_check

from django.core.serializers import serialize
from django.forms.models import model_to_dict
from django.urls import reverse
from todo.forms import EventForm
from todo.models import Evento

from django_q.tasks import async_task, schedule
from django_q.models import Schedule
from django.utils import timezone


@login_required
@user_passes_test(staff_check)
def calendario(request):
	form = EventForm(request.POST)
	if form.is_valid():
		form.save()
	
		#Fetch last event
		event = Evento.objects.last()
	
		#Get event notify request
		notify_request = event.notify
		
		if notify_request:
			
			#get current user
			currentuser = request.user
				
			#Get notify_time
			notify_time = event.notify_time
			
			#Get event isRecur
			isRecur = event.isRecur
			
			#Get event allDay 
			allDay = event.allDay
			
			#Get event title
			event_title = event.title
			
			#prepare send_mail function
			from_email = settings.EMAIL_HOST_USER
			subject = 'Promemoria evento | SmartInvoice'
			context = {'title' : event_title}
			html_content = render_to_string('mail.html', context)

			if isRecur:
				
				#Get event recurrence start date
				event_recur_start_date = str(event.startRecur)
				
				#Get event recurrence end date
				event_recur_end_date = str(event.endRecur)

				#Get event dayOfWeek
				dayOfWeek = event.daysOfWeek
				if dayOfWeek == '[0]':
					dayOfWeek = 'Sunday'
				if dayOfWeek == '[1]':
					dayOfWeek = 'Monday'
				if dayOfWeek == '[2]':
					dayOfWeek = 'Tuesday'
				if dayOfWeek == '[3]':
					dayOfWeek = 'Wednesday'
				if dayOfWeek == '[4]':
					dayOfWeek = 'Thursday'
				if dayOfWeek == '[5]':
					dayOfWeek = 'Friday'
				if dayOfWeek == '[6]':
					dayOfWeek = 'Saturday'
								

				#Calc dates for alerts
				firstDay = datetime.strptime(event_recur_start_date, '%Y-%m-%d') 
				lastDay = datetime.strptime(event_recur_end_date, '%Y-%m-%d')
				dates = [firstDay + timedelta(days=x) for x in range((lastDay-firstDay).days + 1) if (firstDay + timedelta(days=x)).weekday() == time.strptime(dayOfWeek, '%A').tm_wday]
				
				
				for i in dates:
					
					if notify_time == '1':
						msg = 'Ti ricordo l\'evento ' + event_title + ' in scadenza domani'
						delta = i - timedelta(days=1)
					if notify_time == '7':
						msg = 'Ti ricordo l\'evento ' + event_title + ' in scadenza la prossima settimana'
						delta = i - timedelta(days=7)
					
					#make dates timezone aware from naive
					aware_dates = timezone.make_aware(delta)
					
					#assign task to DjangoQ
					schedule('django.core.mail.send_mail', subject, msg, from_email, [currentuser.email], fail_silently=False, html_message=html_content, schedule_type=Schedule.ONCE, next_run=aware_dates)
							
				
			else:
			
				#Get event start date
				event_start_date = event.start
		
				if notify_time == '1':
					msg = 'Ti ricordo l\'evento ' + event_title + ' in scadenza domani'
					delta = event_start_date - timedelta(days=1)
				if notify_time == '7':
					msg = 'Ti ricordo l\'evento ' + event_title + ' in scadenza la prossima settimana'
					delta = event_start_date - timedelta(days=7)
					
				#assign task to DjangoQ
				schedule('django.core.mail.send_mail', subject, msg, from_email, [currentuser.email], fail_silently=False, html_message=html_content, schedule_type=Schedule.ONCE, next_run=delta)

		return render(request, 'todo/calendar.html', context={'form': EventForm()})
	return render(request, 'todo/calendar.html', context={'form': EventForm()})
	
@login_required
@user_passes_test(staff_check)	
def events_list(request):
	events = Evento.objects.all()
	return JsonResponse(list(map(lambda x: model_to_dict(x), events)), safe=False)

	
@login_required
@user_passes_test(staff_check)	
def delete_event(request):
	ajaxvardict = json.loads(request.POST['data'])
	id_to_delete = ajaxvardict.get('eventId')
	
	b = get_object_or_404(Evento, pk = id_to_delete)
	b.delete()
	try:
		os.remove("json/%s.json" % id_to_delete)
		os.remove("json/%s.html" % id_to_delete)
	except OSError:
		pass
		
	return render(request, 'todo/calendar.html', context={'form': EventForm()})
	
	