
from django.shortcuts import render, get_object_or_404, redirect
from django.http import HttpResponse, Http404, HttpRequest
from django.contrib import messages
import json
from subprocess import Popen, PIPE
from datetime import datetime, timedelta
import time
from django.http import JsonResponse, HttpResponse, HttpResponseRedirect
from django.conf import settings
from django.template.loader import get_template, render_to_string
from django.contrib.auth.decorators import login_required, user_passes_test
from todo.utils import staff_check

from django.core.serializers import serialize
from django.forms.models import model_to_dict
from django.urls import reverse
from todo.forms import EventForm
from todo.models import Evento

from django_q.tasks import schedule, Schedule
from django.utils import timezone

from django.core.cache import cache


@login_required
@user_passes_test(staff_check)
def calendario(request):
	
	form = EventForm(request.POST)

	if form.is_valid():
		form.save()
	
	try:
		data = Evento.objects.latest('id')
		eventID = data.id
	except Evento.DoesNotExist:
		eventID = None

	#Make a copy of the form just submitted/filled  by the user
	request.POST.copy()
	
	#Get notify request
	notify_time  = request.POST.get('notify_time')
	
	#L'utente vuole essere avvisato dell'evento
	if notify_time is not None:
		
		#Get current user
		currentuser = request.user
		
		#Get event isRecur
		isRecur = request.POST.get('isRecur')
		
		#Get event allDay 
		allDay = request.POST.get('allDay')
		
		#Get event title
		event_title = request.POST.get('title')
		
		#Get event start date
		event_start_date = request.POST.get('start')
		
		#Get event start time
		event_start_time = request.POST.get('startTime')
		
		#Get event recurrence start date
		event_recur_start_date = request.POST.get('startRecur')
				
		#Get event recurrence end date
		event_recur_end_date = request.POST.get('endRecur')
		
		#Get event recurring cadence
		recur_everyday = request.POST.get('recur_everyday')
		
		#Initialize variable with a casual datetime object
		delta = timezone.now()
		
		#Prepare send_mail function
		from_email = settings.EMAIL_HOST_USER
		subject = 'Promemoria evento | SmartInvoice'
		msg = ''
		html_content = ''
		
		#Evento singolo che non ha un'orario impostato		
		if allDay == 'on' and isRecur is None:
		
			#Trasforma la data da stringa a oggetto data senza tenere conto dell'orario
			event_start_date_converted = datetime.strptime(event_start_date, '%d/%m/%Y') 
		
			#Aggiungi fuso orario
			aware_date = timezone.make_aware(event_start_date_converted)

			#Calc dates for alerts
			#1 giorno prima
			if notify_time == '1D':
				msg = 'SmartInvoice ti ricorda l\'evento ' + event_title + ' in scadenza domani'
				context = {'msg' : msg}
				html_content = render_to_string('calendar_mail.html', context)
				delta = aware_date - timedelta(days=1)
				
			#1 settimana prima
			if notify_time == '7D':
				msg = 'SmartInvoice ti ricorda l\'evento ' + event_title +  ' in scadenza la prossima settimana'
				context = {'msg' : msg}
				html_content = render_to_string('calendar_mail.html', context)
				delta = aware_date - timedelta(days=7)
			
			
			#Assign task to DjangoQ
			schedule('django.core.mail.send_mail', subject, msg, from_email, [currentuser.email], fail_silently=False, html_message=html_content, evento_calendar=eventID, schedule_type=Schedule.ONCE, next_run=delta, cluster='DjangORMcalendarApp')
		
		#Evento singolo con orario impostato
		if allDay is None and isRecur is None:
			
			#Trasforma la data da stringa a oggetto data tenendo conto dell'orario
			event_start_date_converted = datetime.strptime(event_start_date, '%d/%m/%Y %H:%M') 
			
			#Aggiungi fuso orario
			aware_date = timezone.make_aware(event_start_date_converted)

			#Calc dates for alerts	
			#1 ora prima
			if notify_time == '1H':
				delta = aware_date - timedelta(hours=1)
				msg = 'SmartInvoice ti ricorda l\'evento ' + event_title + ' in scadenza fra un\'ora, alle ' + str(aware_date.hour) + ':' + str(aware_date.minute)
				context = {'msg' : msg}
				html_content = render_to_string('calendar_mail.html', context)
			
			#1 giorno prima
			if notify_time == '1D':
				msg = 'SmartInvoice ti ricorda l\'evento ' + event_title + ' in scadenza domani'
				delta = aware_date - timedelta(days=1)
				context = {'msg' : msg}
				html_content = render_to_string('calendar_mail.html', context)
				
			#1 settimana prima
			if notify_time == '7D':
				msg = 'SmartInvoice ti ricorda l\'evento ' + event_title +  ' in scadenza la prossima settimana'
				delta = aware_date - timedelta(days=7)
				context = {'msg' : msg}
				html_content = render_to_string('calendar_mail.html', context)
				
			#Assign task to DjangoQ
			schedule('django.core.mail.send_mail', subject, msg, from_email, [currentuser.email], fail_silently=False, html_message=html_content, evento_calendar=eventID,  schedule_type=Schedule.ONCE, next_run=delta, cluster='DjangORMcalendarApp')


		#Evento ricorrente che ha un orario impostato e una cadenza specifica
		if isRecur == 'on' and event_start_time is not None and recur_everyday is None:
			
			#Trasforma in oggetto data l'ora di inizio evento ricorrente
			event_start_time_converted = datetime.strptime(event_start_time, '%H:%M') 
	
			#Get event dayOfWeek
			dayOfWeek = request.POST.get('daysOfWeek')
			if dayOfWeek == '[0]':
				dayOfWeek = 'Sunday'
			if dayOfWeek == '[1]':
				dayOfWeek = 'Monday'
			if dayOfWeek == '[2]':
				dayOfWeek = 'Tuesday'
			if dayOfWeek == '[3]':
				dayOfWeek = 'Wednesday'
			if dayOfWeek == '[4]':
				dayOfWeek = 'Thursday'
			if dayOfWeek == '[5]':
				dayOfWeek = 'Friday'
			if dayOfWeek == '[6]':
				dayOfWeek = 'Saturday'
			
					
			#Convert strings into date objects
			firstDay = datetime.strptime(event_recur_start_date, '%Y-%m-%d') 
			lastDay = datetime.strptime(event_recur_end_date, '%Y-%m-%d')
			
			#Calc dates for alerts
			dates = [firstDay + timedelta(days=x) for x in range((lastDay-firstDay).days + 1) if (firstDay + timedelta(days=x)).weekday() == time.strptime(dayOfWeek, '%A').tm_wday]
			
			for i in dates:
			
				date_def = i.replace(hour=event_start_time_converted.hour, minute=event_start_time_converted.minute)
				
				#Aggiungi fuso orario all'orario d'inizio evento
				aware_start_dates = timezone.make_aware(date_def)
					
				#1 ora prima
				if notify_time == '1H':
					delta = aware_start_dates - timedelta(hours=1)
					msg = 'SmartInvoice ti ricorda l\'evento ' + event_title + ' in scadenza fra un\'ora, alle ' + str(aware_start_dates.hour) + ':' + str(aware_start_dates.minute)
					context = {'msg' : msg}
					html_content = render_to_string('calendar_mail.html', context)
					
				#1 giorno prima
				if notify_time == '1D':
					msg = 'SmartInvoice ti ricorda l\'evento ' + event_title + ' in scadenza domani'
					delta = aware_start_dates - timedelta(days=1)
					context = {'msg' : msg}
					html_content = render_to_string('calendar_mail.html', context)	
					
				#1 settimana prima	
				if notify_time == '7D':
					msg = 'SmartInvoice ti ricorda l\'evento ' + event_title +  ' in scadenza la prossima settimana'
					delta = aware_start_dates - timedelta(days=7)
					context = {'msg' : msg}
					html_content = render_to_string('calendar_mail.html', context)
				
				#Assign task to DjangoQ
				schedule('django.core.mail.send_mail', subject, msg, from_email, [currentuser.email], fail_silently=False, html_message=html_content, evento_calendar=eventID,  schedule_type=Schedule.ONCE, next_run=delta,  cluster='DjangORMcalendarApp')
				
			
		#Evento ricorrente che non ha un orario impostato e una cadenza specifica
		if isRecur == 'on' and event_start_time is None and recur_everyday is not None:

			#Convert strings into date objects
			firstDay = datetime.strptime(event_recur_start_date, '%Y-%m-%d') 
			lastDay = datetime.strptime(event_recur_end_date, '%Y-%m-%d')
			
			#Calc dates for alerts
			
			#DA SISTEMARE
			dates = [firstDay + timedelta(days=x) for x in range((lastDay-firstDay).days + 1)]
			
			"""
			for i in dates:
				#1 giorno prima
				if notify_time == '1D':
					msg = 'SmartInvoice ti ricorda l\'evento ' + event_title + ' in scadenza domani'
					delta = i - timedelta(days=1)
					context = {'msg' : msg}
					html_content = render_to_string('calendar_mail.html', context)
				
				#1 settimana prima	
				if notify_time == '7D':
					msg = 'SmartInvoice ti ricorda l\'evento ' + event_title +  ' in scadenza la prossima settimana'
					delta = i - timedelta(days=7)
					context = {'msg' : msg}
					html_content = render_to_string('calendar_mail.html', context)
				
				#Make dates timezone aware from naive
				#aware_dates = timezone.make_aware(delta)
				
				#Assign task to DjangoQ
				schedule('django.core.mail.send_mail', subject, msg, from_email, [currentuser.email], fail_silently=False, html_message=html_content, evento_calendar=eventID,  schedule_type=Schedule.ONCE, next_run=delta, cluster='DjangORMcalendarApp')
			"""
			
	return render(request, 'todo/calendar.html', context={'form': EventForm()})

	
@login_required
@user_passes_test(staff_check)	
def events_list(request):
	events = Evento.objects.all()
	return JsonResponse(list(map(lambda x: model_to_dict(x), events)), safe=False)

	
@login_required
@user_passes_test(staff_check)	
def delete_event(request):
	#get ajax variable that tell us event_id to be removed
	ajax_response_dict = json.loads(request.POST['data'])
	id_to_delete = ajax_response_dict.get('eventId')
	
	#Elimina evento dal database
	evento_db = get_object_or_404(Evento, pk = id_to_delete)
	evento_db.delete()
	
	#Associa nome evento del database con il nome evento dello scheduled task di djangoQ
	job = Schedule.objects.filter(evento_calendar=id_to_delete)
	
	#Elimina evento dagli scheduled Task di DjangoQ
	job.delete()

	return render(request, 'todo/calendar.html', context={'form': EventForm()})