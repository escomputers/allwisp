
from django.shortcuts import render, get_object_or_404, redirect
from django.http import HttpResponse, Http404, HttpRequest
from django.contrib import messages
import json
from subprocess import Popen, PIPE
from datetime import datetime, timedelta
import time
from django.http import JsonResponse, HttpResponse, HttpResponseRedirect
from django.conf import settings
from django.template.loader import get_template, render_to_string
from django.contrib.auth.decorators import login_required, user_passes_test
from todo.utils import staff_check

from django.core.serializers import serialize
from django.forms.models import model_to_dict
from django.urls import reverse
from todo.forms import EventForm
from todo.models import Evento

from django_q.tasks import async_task, schedule
from django_q.models import Schedule
from django.utils import timezone

from django.core.cache import cache


@login_required
@user_passes_test(staff_check)
def calendario(request):
	
	form = EventForm(request.POST)
	if form.is_valid():
		form.save()
	
	#Make a copy of the form just submitted/filled  by the user
	request.POST.copy()

	#Get notify request
	notify_time  = request.POST.get('notify_time')
		

	#L'utene vuole essere avvisato dell'evento
	if notify_time == '1D' or notify_time == '7D' or notify_time == '1H':
		
		#Get current user
		currentuser = request.user
		
		#Get event isRecur
		isRecur = request.POST.get('isRecur')
		
		#Get event allDay 
		allDay = request.POST.get('allDay')
		
		#Get event title
		event_title = request.POST.get('title')
		
		#Get event start date
		event_start_date = request.POST.get('start')
		
		#Initialize variable with a casual datetime object
		delta = timezone.now()
		
		#Prepare send_mail function
		from_email = settings.EMAIL_HOST_USER
		subject = 'Promemoria evento | SmartInvoice'
		context = {'title' : event_title}
		html_content = render_to_string('calendar_mail.html', context)
		msg = ''

		
		#L'evento non e' ricorrente e non c'e' un'orario impostato		
		if allDay == 'on':
		
			#Trasforma la data da stringa a oggetto data senza tenere conto dell'orario
			event_start_date_converted = datetime.strptime(event_start_date, '%Y-%m-%d') 
		
			#Aggiungi fuso orario
			aware_date = timezone.make_aware(event_start_date_converted)

			#Calc dates for alerts
			#1 giorno prima
			if notify_time == '1D':
				msg = 'Ti ricordo l\'evento ' + event_title + ' in scadenza domani'
				delta = aware_date - timedelta(days=1)
				
			#1 settimana prima
			if notify_time == '7D':
				msg = 'Ti ricordo l\'evento ' + event_title +  ' in scadenza la prossima settimana'
				delta = aware_date - timedelta(days=7)
			
			
			#Assign task to DjangoQ
			schedule('django.core.mail.send_mail', subject, msg, from_email, [currentuser.email], fail_silently=False, html_message=html_content, schedule_type=Schedule.ONCE, next_run=delta)
		
		
		#L'evento non e' ricorrente ma c'e' un'orario impostato
		else:
			
			#Trasforma la data da stringa a oggetto data tenendo conto dell'orario
			event_start_date_converted = datetime.strptime(event_start_date, '%d/%m/%Y %H:%M') 
			
			#Aggiungi fuso orario
			aware_date = timezone.make_aware(event_start_date_converted)
			
			#Calc dates for alerts
			#1 ora prima
			if notify_time == '1H':
				delta = aware_date - timedelta(hours=1)
				msg = 'Ti ricordo l\'evento ' + event_title + ' in scadenza domani, alle ' + str(aware_date.hour) + ':00'
			
			
			#Assign task to DjangoQ
			schedule('django.core.mail.send_mail', subject, msg, from_email, [currentuser.email], fail_silently=False, html_message=html_content, schedule_type=Schedule.ONCE, next_run=delta)

			
			
		"""
		if isRecur == 'on':

			#Get event recurrence start date
			event_recur_start_date = request.POST.get('startRecur')
			
			#Get event recurrence end date
			event_recur_end_date = request.POST.get('endRecur')

			#Get event dayOfWeek
			dayOfWeek = request.POST.get('daysOfWeek')
			if dayOfWeek == '[0]':
				dayOfWeek = 'Sunday'
			if dayOfWeek == '[1]':
				dayOfWeek = 'Monday'
			if dayOfWeek == '[2]':
				dayOfWeek = 'Tuesday'
			if dayOfWeek == '[3]':
				dayOfWeek = 'Wednesday'
			if dayOfWeek == '[4]':
				dayOfWeek = 'Thursday'
			if dayOfWeek == '[5]':
				dayOfWeek = 'Friday'
			if dayOfWeek == '[6]':
				dayOfWeek = 'Saturday'
				
			#Calc dates for alerts
			firstDay = datetime.strptime(event_recur_start_date, '%Y-%m-%d') 
			lastDay = datetime.strptime(event_recur_end_date, '%Y-%m-%d')
			dates = [firstDay + timedelta(days=x) for x in range((lastDay-firstDay).days + 1) if (firstDay + timedelta(days=x)).weekday() == time.strptime(dayOfWeek, '%A').tm_wday]
			for i in dates:
				if notify_time == '1D':
					msg = 'Ti ricordo l\'evento ' + event_title + ' in scadenza domani'
					delta = i - timedelta(days=1)
				if notify_time == '7D':
					msg = 'Ti ricordo l\'evento ' + event_title +  ' in scadenza la prossima settimana'
					delta = i - timedelta(days=7)
				
				#Make dates timezone aware from naive
				aware_dates = timezone.make_aware(delta)
				
				#Assign task to DjangoQ
				schedule('django.core.mail.send_mail', subject, msg, from_email, [currentuser.email], fail_silently=False, html_message=html_content, schedule_type=Schedule.ONCE, next_run=aware_dates)
		"""
	
	return render(request, 'todo/calendar.html', context={'form': EventForm()})

	
@login_required
@user_passes_test(staff_check)	
def events_list(request):
	events = Evento.objects.all()
	return JsonResponse(list(map(lambda x: model_to_dict(x), events)), safe=False)

	
@login_required
@user_passes_test(staff_check)	
def delete_event(request):
	#get ajax variable that tell us event_id to be removed
	ajax_response_dict = json.loads(request.POST['data'])
	id_to_delete = ajax_response_dict.get('eventId')

	b = get_object_or_404(Evento, pk = id_to_delete)
	b.delete()
		
	return render(request, 'todo/calendar.html', context={'form': EventForm()})